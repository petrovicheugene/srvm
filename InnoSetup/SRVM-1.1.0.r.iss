; Script generated by the Inno Setup Script Wizard.
; SEE THE DOCUMENTATION FOR DETAILS ON CREATING INNO SETUP SCRIPT FILES!

; !!!  GENERATE NEW GUI !!!
; !!!
; !!!
#define MyAppName "SRVM"
#define MyAppVersion "1.1.0"
#define MyAppFullVersion "1.1.0.r"
#define MyAppExeName "SRVM.exe"
#define MyAppExeBaseName "SRVM"
#define MyAppWindowName "SRVM" 
#define MyAppWindowClassName "MainWindow" 


#define MyAppPublisher "TechnoAnalyt Ltd."
#define MyAppShortPublisher "TechnoAnalyt"
#define MyAppURL "http://tehnoanalit.com/"

#define QtVersion "5.14.1"

#define SourceFolder "D:\QtProjects\SRVM\Qt-5.14.1-SRVM\" 
#define InnoSetupFolder "D:\QtProjects\SRVM\SRVM\InnoSetup\" 
#define QtLibFolder "D:\QtProjects\SRVM\Qt-5.14.1-Lib\" 
#define DocFolder "D:\QtProjects\SRVM\Qt-5.14.1-SRVM\Doc\" 

#define licenseEn "licenseEn.txt"
#define licenseRu "licenseRu.txt"

; !!!  GENERATE NEW GUI !!!
                                                                   
[Setup]
; NOTE: The value of AppId uniquely identifies this application.
; Do not use the same AppId value in installers for other applications.
; (To generate a new GUID, click Tools | Generate GUID inside the IDE.)
AppCopyright = Copyright © TechnoAnalyt Ltd. 2017-2020. All rights reserved.
AppId={{F3FD3407-2E01-4B99-931A-B99C24C88E16}
AppName={#MyAppWindowName}
AppVersion={#MyAppVersion}
AppVerName={#MyAppExeBaseName}
AppPublisher={#MyAppPublisher}
AppPublisherURL={#MyAppURL}
AppSupportURL={#MyAppURL}
;AppUpdatesURL={#MyAppURL}
CreateUninstallRegKey=yes
DefaultDirName={pf}\{#MyAppShortPublisher}\{#MyAppExeBaseName}
DefaultGroupName={#MyAppWindowName}
OutputBaseFilename={#MyAppName}Setup-{#MyAppFullVersion}
Compression=lzma
SolidCompression=yes

WizardImageFile={#InnoSetupFolder}WizModernImage-IS.bmp
WizardSmallImageFile={#InnoSetupFolder}WizModernSmallImage-IS.bmp

[Languages]
Name: "english"; MessagesFile: "compiler:Default.isl"; LicenseFile: "{#DocFolder}licenseEn.txt"
Name: "russian"; MessagesFile: "compiler:Languages\Russian.isl"; LicenseFile: "{#DocFolder}licenseRu.txt"
;InfoBeforeFile={#SourceFolder}before.txt
;InfoAfterFile={#SourceFolder}after.txt


[CustomMessages]
;QtPage
english.QtPageCaption=Select Destination Lacation of Qt{#QtVersion} Library
english.QtPageDescription=Where should Qt{#QtVersion} Library be installed?
english.QtPageSubCaption1=Setup will install Qt{#QtVersion} Library into the following folder.
english.QtPageSubCaption2=To continue, click «Next». If you would like to select a different folder, click «Browse».
;english.QtPageNewFolderName = PNF
 
russian.QtPageCaption=Выбор папки установки библиотек Qt{#QtVersion}
russian.QtPageDescription=В какую папку Вы хотите установить библиотеки Qt{#QtVersion}?
russian.QtPageSubCaption1=Программа установит библиотеки Qt{#QtVersion} в следующую папку. 
russian.QtPageSubCaption2=Нажмите «Далее», чтобы продолжить. Если Вы хотите выбрать другую папку, нажмите «Обзор».
;russian.QtPageNewFolderName = Нажмите «Далее», чтобы продолжить. Если вы хотите выбрать другую папку, нажмите «Обзор»."

;OldVersionPage
english.InstalledVersionPageCaption=Installed version of {#MyAppName} check
english.InstalledVersionPageDescription=The following versions of {#MyAppName} was detected on your computer:
english.InstalledVersionPageDescriptionSingle=The following version of {#MyAppName} were detected on your computer:
english.InstalledVersionPageSubCaption1=Select the one of actions below and click «Next».

english.InstalledVersionPageActionInstSingle=Remove the installed version of {#MyAppName} and continue the installation.
english.InstalledVersionPageActionDelAndInstSingle=Don’t remove the installed version of {#MyAppName} and continue the installation.

english.InstalledVersionPageActionInst=Remove the installed versions of {#MyAppName} and continue the installation.
english.InstalledVersionPageActionDelAndInst=Don’t remove the installed versions of {#MyAppName} and continue the installation.
english.InstalledVersionPageActionExit=Terminate the installation and exit.
;
russian.InstalledVersionPageCaption=Проверка установленных версий {#MyAppName}
russian.InstalledVersionPageDescriptionSingle=На компьютере обнаружена следующая установленная версия {#MyAppName}:
russian.InstalledVersionPageDescription=На компьютере обнаружены следующие установленные версии {#MyAppName}:
russian.InstalledVersionPageSubCaption1=Выберите действие из следующих вариантов и нажмите «Далее». 

russian.InstalledVersionPageActionInstSingle=Удалить установленую версию {#MyAppName} и продолжить установку.
russian.InstalledVersionPageActionDelAndInstSingle=Не удалять уже установленную версию {#MyAppName} и продолжить установку.

russian.InstalledVersionPageActionInst=Удалить установленные версии {#MyAppName} и продолжить установку.
russian.InstalledVersionPageActionDelAndInst=Не удалять уже установленные версии {#MyAppName} и продолжить установку.
russian.InstalledVersionPageActionExit=Прервать установку и выйти.
;

english.RemovingErrorString=Deinstallation error.  
english.AppOccupiedErrorString=The directory is occupied by another version of {#MyAppName}!
english.RemSettingsQuestion=If you keep the application settings on your computer you may import them to the next version of {#MyAppName}.Do you want to keep all application settings?  

russian.RemovingErrorString=Ошибка удаления.
russian.AppOccupiedErrorString=Папка уже занята другой версией {#MyAppName}!
russian.RemSettingsQuestion=Если Вы оставите настройки приложения на Вашем компьютере, то потом сможете импортировать их в следующую версию {#MyAppName}. Оставить все настройки приложения? 

; Settings Page 
english.AppSettingsPageCaption={#MyAppName} settings 
english.AppSettingsPageDescription=There are settings of following versions of {#MyAppName} detected:
english.AppSettingsPageSubCaption=If you want to apply the settings of the previous installation {#MyAppName}, select the one below and click «Next».     
english.DontApplySettings=Don't apply settings.

russian.AppSettingsPageCaption=Настройки {#MyAppName}  
russian.AppSettingsPageDescription=На компьютере обнаружены следующие настройки {#MyAppName}:
russian.AppSettingsPageSubCaption=Если Вы хотите применить настройки предыдущей установки {#MyAppName}, выберите из следующих вариантов и нажмите «Далее». 
russian.DontApplySettings=Не применять настройки.

; Ready Memo
english.ReadyMemoDontApplyVersion=Settings of a previous version {#MyAppName} will not be applied.
english.ReadyMemoApplyVersion1=The settings of
english.ReadyMemoApplyVersion2=will be applied. 
;
russian.ReadyMemoDontApplyVersion=Настройки предыдущих версий {#MyAppName} не будут использованы.
russian.ReadyMemoApplyVersion1=Будут применены настройки версии
russian.ReadyMemoApplyVersion2=.

; CurrentVersionHandlingPage

english.CurrentVersionHandlingPageCaption=Current version of {#MyAppName}
english.CurrentVersionHandlingPageDescription=Application {#MyAppName} {#MyAppVersion} is already installed on your computer.
english.CurrentVersionHandlingPageSubCaption=Select an action from the list below and click «Next».

english.CurrentVersionHandlingPageReinstall=Reinstall {#MyAppName} {#MyAppVersion}
english.CurrentVersionHandlingPageRemove=Remove {#MyAppName} {#MyAppVersion}
english.CurrentVersionHandlingPageExit=Terminate the installation and exit.
;
russian.CurrentVersionHandlingPageCaption=Текущая версия {#MyAppName}
russian.CurrentVersionHandlingPageDescription=Приложение {#MyAppName} {#MyAppVersion} уже установлено на Вашем компьютере.
russian.CurrentVersionHandlingPageSubCaption=Выберите действие из списка ниже и нажмите «Далее».

russian.CurrentVersionHandlingPageReinstall=Переустановить {#MyAppName} {#MyAppVersion}
russian.CurrentVersionHandlingPageRemove=Удалить {#MyAppName} {#MyAppVersion} 
russian.CurrentVersionHandlingPageExit=Прервать установку и выйти.
;

english.CloseApplicationWarning=A running application{#MyAppName} {#MyAppVersion} found. To continue deleting, close the application and click «OK». To exit the deleting procedure click «Cancel». 
russian.CloseApplicationWarning=Обнаружено запущенное приложение {#MyAppName} {#MyAppVersion}. Для продолжения удаления закройте приложение и нажмите «OK». Для выхода из процедуры удаления нажмите «Отмена».


[Dirs]
Name: {code:GetQtFolder}; Check: not QtFolderExists; Flags: uninsalwaysuninstall; 

[Registry]
; Qt Lib
Root: HKLM; Subkey: "SOFTWARE\{#MyAppShortPublisher}"; Flags: uninsdeletekeyifempty 
Root: HKLM; Subkey: "SOFTWARE\{#MyAppShortPublisher}\Qt"; Flags: uninsdeletekeyifempty
Root: HKLM; Subkey: "SOFTWARE\{#MyAppShortPublisher}\Qt\Version"; Flags: uninsdeletekeyifempty
Root: HKLM; Subkey: "SOFTWARE\{#MyAppShortPublisher}\Qt\Version\{#QtVersion}"; ValueType: string; ValueName: "path"; ValueData: "{code:GetQtFolder}"
; Application
Root: HKLM; Subkey: "Software\Microsoft\Windows\CurrentVersion\App Paths\{#MyAppExeName}"; ValueType: string; ValueData: "{app}\{#MyAppExeName}"; Flags: uninsdeletekey  
Root: HKLM; Subkey: "Software\Microsoft\Windows\CurrentVersion\App Paths\{#MyAppExeName}"; ValueType: string; ValueName: "Path"; ValueData: "{code:GetQtFolder}"; Flags: uninsdeletekey  
; App Version Info
Root: HKLM; Subkey: "SOFTWARE\{#MyAppShortPublisher}"; Flags: uninsdeletekeyifempty 
Root: HKLM; Subkey: "SOFTWARE\{#MyAppShortPublisher}\{#MyAppName}"; Flags: uninsdeletekeyifempty
Root: HKLM; Subkey: "SOFTWARE\{#MyAppShortPublisher}\{#MyAppName}\Version"; Flags: uninsdeletekeyifempty
Root: HKLM; Subkey: "SOFTWARE\{#MyAppShortPublisher}\{#MyAppName}\Version\{#MyAppVersion}"; ValueType: string; ValueName: "path"; ValueData: "{app}"; Flags: uninsdeletekey
Root: HKLM; Subkey: "SOFTWARE\{#MyAppShortPublisher}\{#MyAppName}\Version\{#MyAppVersion}"; ValueType: string; ValueName: "appId"; ValueData: "{#emit SetupSetting("AppId")}"; Flags: uninsdeletekey

[Tasks]
Name: "desktopicon"; Description: "{cm:CreateDesktopIcon}"; GroupDescription: "{cm:AdditionalIcons}"; Flags: unchecked

[Files]
;Source: "{#SourceFolder}{#MyAppExeName}"; DestDir: "{app}"; Flags: ignoreversion
Source: "{#SourceFolder}{#MyAppExeName}"; DestDir: "{app}"; Flags: ignoreversion
Source: "{#SourceFolder}SRVM_ru.qm"; DestDir: "{app}"; Flags: ignoreversion
Source: "{#SourceFolder}qtbase_ru.qm"; DestDir: "{app}"; Flags: ignoreversion
Source: "{#SourceFolder}qtbase_en.qm"; DestDir: "{app}"; Flags: ignoreversion
;Source: "{#SourceFolder}ComDV.dll"; DestDir: "{app}"; Flags: ignoreversion
;Source: "{#QtLibFolder}qsqlite.dll"; DestDir: "{app}\sqldrivers"; Flags: ignoreversion

;Source: "{code:GetLicenseFileSource}"; DestDir: "{app}"; Flags: ignoreversion 
;external
Source: "{#DocFolder}*"; DestDir: "{app}\Doc"; Flags: ignoreversion recursesubdirs createallsubdirs
Source: "{#QtLibFolder}*"; DestDir: {code:GetQtFolder}; Flags: sharedfile recursesubdirs createallsubdirs

; NOTE: Don't use "Flags: ignoreversion" on any shared system files

[Icons]
Name: "{group}\{#MyAppWindowName}"; Filename: "{app}\{#MyAppExeName}"; Parameters:"-platformpluginpath ""{code:GetQtFolder}""" 
Name: "{group}\{cm:ProgramOnTheWeb,{#MyAppPublisher}}"; Filename: "{#MyAppURL}" 
Name: "{group}\{cm:UninstallProgram,{#MyAppWindowName}}"; Filename: "{uninstallexe}"
Name: "{commondesktop}\{#MyAppWindowName}"; Filename: "{app}\{#MyAppExeName}"; Parameters:"-platformpluginpath ""{code:GetQtFolder}""" ;Tasks: desktopicon

[Run]
Filename: "{app}\{#MyAppExeName}"; Parameters:"-platformpluginpath ""{code:GetQtFolder}""" ;Description: "{cm:LaunchProgram,{#StringChange(MyAppName, '&', '&&')}}"; Flags: shellexec postinstall skipifsilent;

; Qt Deployment 
; Parameters:"-platformpluginpath ""{code:GetQtFolder}"""; 


[Code]
//===================================================

//===================================================
procedure ExitProcess(uExitCode: UINT);
  external 'ExitProcess@kernel32.dll stdcall';
// global vars
var
  QtFolderPage: TInputDirWizardPage;
  CurrentVersionHandlingPage: TInputOptionWizardPage;
  InstalledVersionHandlingPage: TInputOptionWizardPage;
  InstalledSettingsImportPage: TInputOptionWizardPage;
  InstalledVersions: TArrayOfString;
  InstalledSettings: TArrayOfString;

  InstalledVersionString: String;
  InstalledSettingsCount: Integer;
  QtFolderName: String;
  CurrentVersionInstalled: Boolean;

  RemovingAborted: Boolean;
  IsReinstall: Boolean;
//===================================================
function CmdLineParamExists(const Value: string): Boolean;
var
  I: Integer;  
begin
  Result := False;
  for I := 1 to ParamCount do
    if CompareText(ParamStr(I), Value) = 0 then
    begin
      Result := True;
      Break;
    end;
end;
//===================================================
function GetLicenseFileSource(Param: String): String;
var
  UILang: Integer; 
  FileStr: String;  
begin
  UILang:= GetUILanguage;
  if UILang = $0409 then
  begin
    // UI language is English (United States)
    FileStr:=ExpandConstant('{#SourceFolder}'+'{#licenseEn}');
  end
  else if UILang = $0419 then
  begin
    // Russian
    FileStr:=ExpandConstant('{#SourceFolder}'+'{#licenseRu}');
  end;

  Result:= FileStr;
  //// You can use "and $3FF" to extract the primary language identifier
  //if GetUILanguage and $3FF = $09 then
  //begin
    //// Matches any variant of English
  //end;
end;
//===================================================
function GetQtFolder(Param: String): String;
begin
  Result:= QtFolderName;
end;
//===================================================
function QtFolderExists: Boolean;
begin
 { Find out if data dir already exists }
  Result := DirExists(QtFolderName);
end;
//===================================================
function AppFolderIsOccupied: Boolean;
var
  I: Integer;
  Key: String;
  Path: String;
begin
  for I := 0 to GetArrayLength(InstalledVersions)-1 do
  begin
    Key:= ExpandConstant('SOFTWARE\{#MyAppShortPublisher}\{#MyAppName}\Version'+'\')+InstalledVersions[I];
    if not RegQueryStringValue(HKLM, Key, 'path', Path) then
    begin
      continue;
    end;

    if(Path = ExpandConstant('{app}')) then
    begin
      Result:= true;
      exit;
    end;
  end;

  Result:= false;  
end;
//===================================================
procedure CleanQtVersionRegKey; 
begin
  RegDeleteValue(HKLM, ExpandConstant('SOFTWARE\{#MyAppShortPublisher}\Qt\Version\{#QtVersion}'),'path');
  RegDeleteKeyIfEmpty(HKLM, ExpandConstant('SOFTWARE\{#MyAppShortPublisher}\Qt\Version\{#QtVersion}'));
  RegDeleteKeyIfEmpty(HKLM, ExpandConstant('SOFTWARE\{#MyAppShortPublisher}\Qt\Version'));
  RegDeleteKeyIfEmpty(HKLM, ExpandConstant('SOFTWARE\{#MyAppShortPublisher}\Qt'));
  RegDeleteKeyIfEmpty(HKLM, ExpandConstant('SOFTWARE\{#MyAppShortPublisher}'));
end;
//=================================================== 
function DefineInstalledVersion: Boolean;
var
//  I: Integer;
//  S: String;
  VersionsString: String;
  Action1Str: String;
  Action2Str: String;
  Action3Str: String;
  Description: String;
  I: Integer;
  SelectedIndex: Integer;
begin
//  MsgBox('DEFINE INST VER', mbInformation, MB_OK);
  
  CurrentVersionInstalled:= false;
  if not(RegKeyExists(HKLM, ExpandConstant('SOFTWARE\{#MyAppShortPublisher}\{#MyAppName}\Version'))) then
  begin
//    MsgBox('DEFINE INST VER = FALSE', mbInformation, MB_OK);
    Result:= false;
    exit;
  end;

  if RegGetSubkeyNames(HKLM, ExpandConstant('SOFTWARE\{#MyAppShortPublisher}\{#MyAppName}\Version'), InstalledVersions) then
  begin
//    S := '';
//    for I := 0 to GetArrayLength(InstalledVersions)-1 do
//      S := S + InstalledVersions[I] + #13#10;
//    MsgBox('List of subkeys:'#13#10#13#10 + S, mbInformation, MB_OK);
    Result:= true;
  end 
  else
  begin
    // add any code to handle failure here
    Result:= false;
  end;

  if(InstalledVersionHandlingPage.CheckListBox.Items.Count < 1) then
  begin
    SelectedIndex:=0;
  end
  else
  begin
    SelectedIndex:=InstalledVersionHandlingPage.SelectedValueIndex;
    InstalledVersionHandlingPage.CheckListBox.Items.Clear;
  end;

  VersionsString := ' ';
  for I := 0 to GetArrayLength(InstalledVersions)-1 do
  begin
    VersionsString := VersionsString + InstalledVersions[I];// + #13#10;
    if not(I = GetArrayLength(InstalledVersions)-1) then
    begin
      VersionsString := VersionsString + ', ';
    end
  end;
  VersionsString := VersionsString + '.';  


  if (GetArrayLength(InstalledVersions) = 1)then
  begin
    Action1Str:= ExpandConstant('{cm:InstalledVersionPageActionInstSingle}');
    Action2Str:= ExpandConstant('{cm:InstalledVersionPageActionDelAndInstSingle}');
    Description:= ExpandConstant('{cm:InstalledVersionPageDescriptionSingle}') + VersionsString;  end
  else
  begin
    Action1Str:= ExpandConstant('{cm:InstalledVersionPageActionInst}');
    Action2Str:= ExpandConstant('{cm:InstalledVersionPageActionDelAndInst}');
    Description:= ExpandConstant('{cm:InstalledVersionPageDescription}') + VersionsString;
  end;

  InstalledVersionHandlingPage.Add(Action1Str);
  InstalledVersionHandlingPage.Add(Action2Str);
  InstalledVersionHandlingPage.Add(ExpandConstant('{cm:InstalledVersionPageActionExit}'));

  InstalledVersionHandlingPage.Description:=Description;

  InstalledVersionHandlingPage.SelectedValueIndex:= SelectedIndex;

  for I := 0 to GetArrayLength(InstalledVersions)-1 do
  begin
    if(InstalledVersions[I] = ExpandConstant('{#MyAppFullVersion}')) then
    begin
      CurrentVersionInstalled:=true;
      break;
    end;
  end;

  Result:=true;

end;
//===================================================
function DefineInstalledSettings: Boolean;
var 
  RegKey: String;
  Caption: String;
  I: Integer;
  C: Integer;
  //InstalledSettings: TArrayOfString;
  Component: TComponent;
  CurrentSelectedSettings: String;
  CurrentSelectedIndex: Integer;
  CurrentSelectionFound: Boolean;
begin
 
  SetArrayLength(InstalledSettings, 0);
  CurrentSelectedIndex:= InstalledSettingsImportPage.SelectedValueIndex;
  if(CurrentSelectedIndex > 0) then
  begin
    CurrentSelectedSettings:= InstalledSettingsImportPage.CheckListBox.ItemCaption[CurrentSelectedIndex];
  end;
  CurrentSelectedIndex:= 0;

  InstalledSettingsImportPage.CheckListBox.Items.Clear; 

  RegKey:= ExpandConstant('SOFTWARE\{#MyAppShortPublisher}\{#MyAppName}');
  RegGetSubkeyNames(HKCU, RegKey, InstalledSettings)
  InstalledSettingsCount:=GetArrayLength(InstalledSettings);

  if (InstalledSettingsCount < 1) then
  begin
    Result:=false;
  end
  else if((InstalledSettingsCount = 1) and (InstalledSettings[0] = '{#MyAppFullVersion}')) then
  begin
    Result:=false;
  end
  else
  begin

    InstalledSettingsImportPage.Add(ExpandConstant('{cm:DontApplySettings}'));
    CurrentSelectionFound:= false;
    for I := 0 to GetArrayLength(InstalledSettings)-1 do
    begin
      if(InstalledSettings[I] = '{#MyAppFullVersion}') then continue;
      
      Caption:= ExpandConstant('{#MyAppName} ') + InstalledSettings[I];
      
      if(not CurrentSelectionFound)  then
      begin
        if(Caption = CurrentSelectedSettings) then
        begin
          CurrentSelectedIndex:= I + 1;
          CurrentSelectionFound:= true;
        end;
      end;
      
      InstalledSettingsImportPage.Add(Caption);
    end;
    
    if((CurrentSelectedIndex < 0) or (CurrentSelectedIndex > InstalledSettingsImportPage.CheckListBox.Items.Count - 1) ) then
    begin
      CurrentSelectedIndex:= 0;
    end;
    InstalledSettingsImportPage.SelectedValueIndex:= CurrentSelectedIndex;
    
    Result:=true;
  end;
end;
//===================================================
function InitializeSetup(): Boolean;
begin
  InstalledSettingsCount:= 0;
  CurrentVersionInstalled:= false;
  IsReinstall:= false;
  //DefineInstalledVersion;
  Result:=true; 
end; 
//===================================================
// custom wizard page setup, for data dir.
procedure InitializeWizard;
var
  Caption: String;
  Description: String;
  SubCaption: String;
  NewFolderName: String;
  BtnImage: TBitmapImage;

begin
    
    // CurrentVersionHandlingPage
    Caption:= ExpandConstant('{cm:CurrentVersionHandlingPageCaption}');
    SubCaption:= ExpandConstant('{cm:CurrentVersionHandlingPageSubCaption}');
    Description:= ExpandConstant('{cm:CurrentVersionHandlingPageDescription}');
    
    CurrentVersionHandlingPage := CreateInputOptionPage(wpWelcome,
      Caption, Description,
      SubCaption,
      True, False);

    CurrentVersionHandlingPage.Add(ExpandConstant('{cm:CurrentVersionHandlingPageReinstall}'));
    CurrentVersionHandlingPage.Add(ExpandConstant('{cm:CurrentVersionHandlingPageRemove}'));
    CurrentVersionHandlingPage.Add(ExpandConstant('{cm:CurrentVersionHandlingPageExit}'));
    CurrentVersionHandlingPage.SelectedValueIndex:= 0;

    // Installed Versions Page
    Caption:= ExpandConstant('{cm:InstalledVersionPageCaption}');
    SubCaption:= ExpandConstant('{cm:InstalledVersionPageSubCaption1}');

    InstalledVersionHandlingPage := CreateInputOptionPage(CurrentVersionHandlingPage.ID,
      Caption, Description,
      SubCaption,
      True, False);
  //end;

  // Qt Page
  Caption:= ExpandConstant('{cm:QtPageCaption}');
  Description:= ExpandConstant('{cm:QtPageDescription}');
  SubCaption:= ExpandConstant('{cm:QtPageSubCaption1}')+Chr(13)+Chr(13)+Chr(10)+ExpandConstant('{cm:QtPageSubCaption2}');
  // NewFolderName:= ExpandConstant('{cm:QtPageNewFolderName}');
  NewFolderName:= ExpandConstant('{pf}')+'/TechnoAnalyt/Qt'+ExpandConstant('{#QtVersion}');

  QtFolderPage := CreateInputDirPage(
    wpSelectDir,
    Caption, // page header
    Description, // message after header
    SubCaption,
    False,
    NewFolderName
  );

  // Settings Page
  Caption:=ExpandConstant('{cm:AppSettingsPageCaption}'); 
  Description:=ExpandConstant('{cm:AppSettingsPageDescription}');
  SubCaption:=ExpandConstant('{cm:AppSettingsPageSubCaption}');
  
  InstalledSettingsImportPage := CreateInputOptionPage(wpSelectDir,
      Caption, 
      Description,
      SubCaption,
      True, False);

  // Settings import
  //InstalledSettingsImportPage: TInputOptionWizardPage;

    // Picture
//  BtnImage := TBitmapImage.Create(QtFolderPage);
//  with BtnImage do 
//  begin

//    Parent := QtFolderPage.Surface;
//    Bitmap.LoadFromFile('D:\Qt_Projects\ZInnoSetupTests\innoSetupOutput\QtLogoSmall.bmp');
    //AutoSize := True;
//    Width:=32;
//    Height:=32;
    //Left := 0;
    //Top := 0;//QtFolderPage.Top + QtFolderPage.Height - Height - 8;
  //    Cursor := crHand;
  //end;

  QtFolderPage.Add('');
  QtFolderPage.Values[0] := ExpandConstant('{pf}')+'/{#MyAppShortPublisher}/Qt'+ExpandConstant('{#QtVersion}');
end;
//===================================================
function CopyRegistryData(SourceRootKey: Integer; SourceKey: String; TargetRootKey: Integer; TargetKey: String): Boolean;
var 
  RegSubkeys: TArrayOfString;
  RegValueNames: TArrayOfString;
  
  NextSourceSubKey: String;
  NextTargetSubKey: String;
    
  I: Integer;
  Res: Boolean;
  
  RegValueString: String;
  RegValueBinary: AnsiString;
  RegValueDWord: Cardinal;
  WriteRes: Boolean;
  LocalCopyRes: Boolean;

begin
  Res:= true;
  // MsgBox('In TargetKey '+SourceKey, mbInformation, MB_OK);
   
  if(RegGetSubkeyNames(SourceRootKey, SourceKey, RegSubkeys)) then
  begin 
    for I := 0 to GetArrayLength(RegSubkeys)-1 do
    begin
      NextSourceSubKey:=SourceKey+'\'+RegSubkeys[I];
      NextTargetSubKey:=TargetKey+'\'+RegSubkeys[I];
      LocalCopyRes:=CopyRegistryData(SourceRootKey, NextSourceSubKey, TargetRootKey, NextTargetSubKey);
      Res:= Res and LocalCopyRes;
    end;
  end;


  if (RegGetValueNames(SourceRootKey, SourceKey, RegValueNames)) then
  begin
    if(GetArrayLength(RegValueNames) = 0) then
    begin
      // creation a key without value  
      if (RegWriteStringValue(TargetRootKey, TargetKey, 'fakeKey', 'fakeValue')) then
      begin
        RegDeleteValue(TargetRootKey, TargetKey, 'fakeKey'); 
      end;
    end
    else
    begin

      for I := 0 to GetArrayLength(RegValueNames)-1 do
      begin
        //  MsgBox('Read RegV '+RegValueNames[I], mbInformation, MB_OK);
     
        WriteRes:= false;
        if(RegQueryStringValue(SourceRootKey, SourceKey, RegValueNames[I], RegValueString)) then
        begin
          WriteRes:= RegWriteStringValue(TargetRootKey, TargetKey, RegValueNames[I], RegValueString);

          if not(WriteRes) then
          begin 
            WriteRes:= RegWriteExpandStringValue(TargetRootKey, TargetKey, RegValueNames[I], RegValueString);
          end;
        end;
        
        if(RegQueryMultiStringValue(SourceRootKey, SourceKey, RegValueNames[I], RegValueString) and not WriteRes) then
        begin
          WriteRes:= RegWriteMultiStringValue(TargetRootKey, TargetKey, RegValueNames[I], RegValueString);
        end;

        if(RegQueryDWordValue(SourceRootKey, SourceKey, RegValueNames[I], RegValueDWord) and not WriteRes) then
        begin
          WriteRes:= RegWriteDWordValue(TargetRootKey, TargetKey, RegValueNames[I], RegValueDWord);
        end;

        if(RegQueryBinaryValue(SourceRootKey, SourceKey, RegValueNames[I], RegValueBinary) and not WriteRes) then
        begin
          WriteRes:= RegWriteBinaryValue(TargetRootKey, TargetKey, RegValueNames[I], RegValueBinary);
        end;

        Res:= Res and WriteRes;
          
        //if(RegQueryBinaryValue(SourceRootKey, SourceKey, RegValueNames[I], RegValue))then
        //begin
        //  MsgBox('Write RegV '+TargetKey+RegValueNames[I], mbInformation, MB_OK);

        //  Res:= Res and RegWriteBinaryValue(TargetRootKey, TargetKey, RegValueNames[I], RegValue); 
        //end;
      end;
    end;
  end;
   Result:=Res;
end;
//===================================================
procedure CurStepChanged(CurStep: TSetupStep);
var
  SelectedIndex: Integer;
  VersionString: String;
  SelectedString: String;
  SourceRegKey: String;
  NewRegKey: String;
  AppName: String;
  
begin
    if CurStep = ssPostInstall then 
    begin
      SelectedIndex:= InstalledSettingsImportPage.SelectedValueIndex;
      if(SelectedIndex < 1) then
      begin
        exit;
      end;

      SelectedString:= InstalledSettingsImportPage.CheckListBox.ItemCaption[SelectedIndex];
      
      Delete(SelectedString, 1, Length(ExpandConstant('{#MyAppName}')));
      VersionString:=Trim(SelectedString);

      //MsgBox('AFTER INST VERSION '+VersionString, mbInformation, MB_OK);
      SourceRegKey:= ExpandConstant('SOFTWARE\{#MyAppShortPublisher}\{#MyAppName}\'+VersionString);
      if not(RegKeyExists(HKCU, SourceRegKey)) then
      begin
        exit;
      end;

      NewRegKey:= ExpandConstant('SOFTWARE\{#MyAppShortPublisher}\{#MyAppName}\{#MyAppFullVersion}');

      CopyRegistryData(HKCU, SourceRegKey, HKCU, NewRegKey);

    end;
end;
//===================================================
procedure RemoveOnePrevInstallation(Version: String; SilentFlag: Boolean; KeepSettingsFlag: Boolean);
var
    I: Integer;
    Key: String;
    Path: String;
    AppId: String;
    iResultCode: Integer;

    RegUnInstKey: String;
    UnInstallString: String;
    DeinstallRes: Boolean;
    ParamString: String;


begin
      Key:= ExpandConstant('SOFTWARE\{#MyAppShortPublisher}\{#MyAppName}\Version'+'\')+Version;
      Path:= '';
      AppId:= '';
      UnInstallString := '';
      iResultCode:= -1;
      RemovingAborted:=false;

      ParamString:= '/NORESTART';
      if(KeepSettingsFlag) then
      begin
        ParamString:= ParamString + ' /KEEPSETTINGS';
      end;

      if(SilentFlag) then
      begin
        ParamString:= ParamString + ' /SILENT';
      end;

      if RegQueryStringValue(HKLM, Key, 'path', Path) then
      begin
         //unins000.exe
         UnInstallString:= Path+'\'+'unins000.exe';
         if(FileExists(UnInstallString)) then
         begin
            //if Exec(UnInstallString, '/SILENT /NORESTART /SUPPRESSMSGBOXES','', SW_HIDE, ewWaitUntilTerminated, iResultCode) then
            if Exec(UnInstallString, ParamString,'', SW_HIDE, ewWaitUntilTerminated, iResultCode) then
            begin
              if (iResultCode = 1) then
              begin
                RemovingAborted:=true;
              end;
              exit;
             end
            else
            begin
              MsgBox(ExpandConstant('{#MyAppName}'+' '+Version+' - '+ SysErrorMessage(iResultCode)), mbInformation, MB_OK);
            end;
         end;
      end;
      
      if RegQueryStringValue(HKLM, Key, 'appId', AppId) then
        begin
          RegUnInstKey := 'Software\Microsoft\Windows\CurrentVersion\Uninstall\'+AppId+'_is1';
              
          if not RegQueryStringValue(HKLM, RegUnInstKey, 'UninstallString', UnInstallString) then
             RegQueryStringValue(HKCU, RegUnInstKey, 'UninstallString', UnInstallString);
              
          //if Exec(UnInstallString, '/SILENT /NORESTART /SUPPRESSMSGBOXES','', SW_HIDE, ewWaitUntilTerminated, iResultCode) then
          if Exec(UnInstallString, ParamString,'', SW_HIDE, ewWaitUntilTerminated, iResultCode) then
          begin
            if (iResultCode = 1) then
            begin
              RemovingAborted:=true;
            end;
            exit;
          end
          else
          begin
            MsgBox(ExpandConstant('{#MyAppName}'+' '+Version+' - '+ SysErrorMessage(iResultCode)), mbInformation, MB_OK);
            exit;
          end;
      end;
 
      MsgBox(ExpandConstant('{#MyAppName}'+' '+Version+' - '+'{cm:RemovingErrorString}') , mbInformation, MB_OK);

end;
//===================================================
procedure RemovePrevInstallations;
var
    I: Integer;
    Key: String;
    Path: String;
    AppId: String;
    iResultCode: Integer;

    RegUnInstKey: String;
    UnInstallString: String;
    DeinstallRes: Boolean;
begin 
    for I := 0 to GetArrayLength(InstalledVersions)-1 do
    begin
      RemoveOnePrevInstallation(InstalledVersions[I], true, false);
    end;
end; 
//===================================================
function BackButtonClick(CurPageID: Integer): Boolean;
begin
    if(CurPageID = wpLicense) then
    begin
      DefineInstalledVersion;
      Result:= true;
      exit;
    end
    else
    begin
      Result:= true;
    end;
end;

//procedure ExitProcess(exitCode:integer);
  //external 'ExitProcess@kernel32.dll stdcall';
//===================================================
function NextButtonClick(CurPageID: Integer): Boolean;
begin
  if(CurPageID = QtFolderPage.ID) then
  begin
      if QtFolderPage.Values[0] = '' then
         QtFolderPage.Values[0] := ExpandConstant('{pf}\{#MyAppShortPublisher}\Qt{#QtVersion}');

         QtFolderName:= QtFolderPage.Values[0];
         Result:= true;
         exit;
  end
  else if (CurPageID = wpWelcome) then
  begin
    DefineInstalledVersion;
    Result:= true;
    exit;
  end
  else if(CurPageID = InstalledVersionHandlingPage.ID) then
  begin
      if(InstalledVersionHandlingPage.SelectedValueIndex = 0) then
      begin
        RemovePrevInstallations;
        Result:= true;
        exit;
      end
      else if(InstalledVersionHandlingPage.SelectedValueIndex = 2) then
      begin
        // exit installation
        WizardForm.Close;
        Result:= false;
        exit;
      end
      else 
      begin
        // continue installation
        Result:= true;
        exit;
      end;
  end
  else if(CurPageID = wpSelectDir) then
  begin
    if(AppFolderIsOccupied) then
    begin
      MsgBox(ExpandConstant('{app}'+' '+'{cm:AppOccupiedErrorString}') , mbInformation, MB_OK);
      Result:= false;
    end
    else
    begin
      DefineInstalledSettings;
      Result:= true;
    end;
    exit;
  end
  else if(CurPageID = CurrentVersionHandlingPage.ID) then
  begin
    if(CurrentVersionHandlingPage.SelectedValueIndex = 0) then
    begin
      RemoveOnePrevInstallation(ExpandConstant('{#MyAppVersion}'), true, true);
      DefineInstalledVersion;
    
      if not(RemovingAborted) then
      begin
       IsReinstall:= true;
       Result:=true;
      end
      else
      begin
        IsReinstall:= false;
        Result:=false;
      end;

      exit;
    end
    else if(CurrentVersionHandlingPage.SelectedValueIndex = 1) then
    begin
      RemoveOnePrevInstallation(ExpandConstant('{#MyAppVersion}'), false, false);
      //WizardForm.Close;
      //SendMessage (WizardForm.Handle, $0010, 0, 0);  { quit setup, $0010=WM_CLOSE }
      if not(RemovingAborted) then
      begin
        ExitProcess(0);
      end;
        Result:=false;
        exit;
      
    end
    else
    begin
      //WizardForm.Close;
      //SendMessage (WizardForm.Handle, $0010, 0, 0);  { quit setup, $0010=WM_CLOSE }
      ExitProcess(0);
      Result:= false;
      exit;
    end;
  end;

  Result:= true;
end;
//===================================================
function ShouldSkipPage(PageID: Integer): Boolean;
var
  Value: String;
begin
  { Skip pages that shouldn't be shown }
  //if (PageID = LightMsgPage.ID) and (UsagePage.SelectedValueIndex <> 0) then
    //Result := True
  //else if (PageID = KeyPage.ID) and (UsagePage.SelectedValueIndex <> 2) then
    //Result := True
  //else
  if(PageID = QtFolderPage.ID) then
  begin
     if RegQueryStringValue(HKLM, ExpandConstant('SOFTWARE\{#MyAppShortPublisher}\Qt\Version\{#QtVersion}'),'path',Value) then 
     begin
        if DirExists(Value) then
        begin
          QtFolderName:= Value; 
          Result := true;   
        end
        else
        begin
          CleanQtVersionRegKey;
          Result := false;
        end;
      end
     else
     begin
        Result := false;
     end;
  end
  else if(PageID = InstalledVersionHandlingPage.ID) then
  begin
     if (GetArrayLength(InstalledVersions) > 0) then
     begin
       Result := false;
     end
     else
     begin
       Result := true;
     end;
  end
  else if(PageID = InstalledSettingsImportPage.ID) then
  begin
    if((InstalledSettingsCount > 1) and not(IsReinstall)) then
    begin
      Result:=false;
    end
    else if((InstalledSettingsCount = 1) and (InstalledSettings[0] = '{#MyAppFullVersion}') and not(IsReinstall)) then
    begin
      Result:=true;
    end
    else
    begin
      Result:=true;
    end;
  end
  else if(PageID = CurrentVersionHandlingPage.ID) then
  begin
    if CurrentVersionInstalled then
    begin
      Result:=false;
    end
    else
    begin
      Result:=true;
    end;
  end
  else 
  begin
      
     Result := false;
  end;
  //InstalledVersionHandlingPage: TInputOptionWizardPage;
  //InstalledVersions: TArrayOfString;

end;
//===================================================
function isEmptyDir(dirName: String): Boolean;
var
  FindRec: TFindRec;
  FileCount: Integer;
begin
  Result := False;
  if FindFirst(dirName+'\*', FindRec) then begin
    try
      repeat
        if (FindRec.Name <> '.') and (FindRec.Name <> '..') then begin
          FileCount := 1;
          break;
        end;
      until not FindNext(FindRec);
    finally
      FindClose(FindRec);
      if FileCount = 0 then Result := True;
    end;
  end;
end;
//===================================================
function getParentFolder(path: String): String;
var
  parent: String;
  drive: String;
begin
   parent:= ExtractFileDir(path);
   drive:= ExtractFileDrive(path);
   
   if not(parent = drive) then 
    begin
    Result:= parent;
    exit;
   end;

   Result:= '';
end;
//===================================================
function IsRoot(path: String): Boolean;
var 
  drive: String;
begin
  if(path = '') then 
  begin
    Result:= false;
    exit;
  end;

  drive:= ExtractFileDrive(path);
  Result:= drive+'\' = path; 
end;
//===================================================
procedure removeFolderBranch(path: String);
begin
    while not (IsRoot(path)) do
    begin
      if(DirExists(path)) then
      begin
        if(isEmptyDir(path)) then
        begin
           if not(RemoveDir(path)) then
           begin
             exit;
           end;
        end
        else
        begin
           exit;
        end;

      end;
 
      path:= getParentFolder(path);
    end;

end;
//===================================================  
function CheckLaunchedApp: Boolean;
var
  winHwnd: longint;
  strProg: String;

begin
  Result:=false;
  exit;
// MyAppWindowClassName

  strProg := ExpandConstant('{#MyAppWindowClassName}');
  
  winHwnd := FindWindowByClassName(strProg);
  //Or FindWindowByWindowName.  If using by Name, the name must be exact and is case sensitive.
  if(winHwnd = 0) then
  begin
    winHwnd := FindWindowByWindowName(strProg);
  end;
  
//  if winHwnd = 0 then
//  begin
//   strProg := ExpandConstant('{#MyAppWindowName}');
//      winHwnd := FindWindowByClassName(strProg);
//    //Or FindWindowByWindowName.  If using by Name, the name must be exact and is case sensitive.
//    if(winHwnd = 0) then
//    begin
//      winHwnd := FindWindowByWindowName(strProg);
//    end;
//  end;

  if winHwnd = 0 then
  begin
    strProg := ExpandConstant('{#MyAppExeName}');
      winHwnd := FindWindowByClassName(strProg);
    //Or FindWindowByWindowName.  If using by Name, the name must be exact and is case sensitive.
    if(winHwnd = 0) then
    begin
      winHwnd := FindWindowByWindowName(strProg);
    end;
  end;


//  if winHwnd = 0 then
//  begin
//    strProg := ExpandConstant('{#MyAppExeBaseName}');
//      winHwnd := FindWindowByClassName(strProg);
//    //Or FindWindowByWindowName.  If using by Name, the name must be exact and is case sensitive.
//    if(winHwnd = 0) then
//    begin
//      winHwnd := FindWindowByWindowName(strProg);
//    end;
//  end;


  if winHwnd <> 0 then
  begin
    Result:= true; 
  end
  else
  begin
    Result:= false;
  end;

end;

//===================================================
procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep);
var
  QtPath: String;
  RegKey: String;
  ClearQtRegFlag: Boolean;
  RegNamesArray: TArrayOfString;
  AppFolderPath: String;

begin 
  if (CurUninstallStep = usPostUninstall) then
  begin
    ClearQtRegFlag:= true;
    // Qt Folder branch removing
    // Qt Folder 
    if RegQueryStringValue(HKLM, ExpandConstant('SOFTWARE\{#MyAppShortPublisher}\Qt\Version\{#QtVersion}'), 'path', QtPath) then
    begin
      if(DirExists(QtPath)) then
      begin
        if not(IsRoot(QtPath)) then
        begin
          if (isEmptyDir(QtPath)) then
          begin
            removeFolderBranch(QtPath);
          end
          else
          begin
            ClearQtRegFlag:= false;
          end;
        end;
      end;
    end;

    // Qt Registry entries
    if(ClearQtRegFlag) then
    begin
      CleanQtVersionRegKey;
    end;
    
    // AppFolderRemoving
    AppFolderPath:= ExpandConstant('{app}')+'\Doc';
    removeFolderBranch(AppFolderPath);

    // App Settings Removing
    RegKey:= ExpandConstant('SOFTWARE\{#MyAppShortPublisher}\{#MyAppName}\{#MyAppFullVersion}');
    // MsgBox(ExpandConstant('Settings REGKEY - '+RegKey) , mbInformation, MB_OK);
    if (RegKeyExists(HKCU, RegKey) and not CmdLineParamExists('/KEEPSETTINGS')) then
    begin
      if MsgBox(ExpandConstant('{cm:RemSettingsQuestion}'), mbConfirmation, MB_YESNO) = IDNO then
      begin
        // user clicked Yes
        if(RegDeleteKeyIncludingSubkeys(HKCU, RegKey)) then
        begin
        
          RegKey:= ExpandConstant('SOFTWARE\{#MyAppShortPublisher}\{#MyAppName}'); 
          RegDeleteKeyIfEmpty(HKLM, RegKey);
          
          RegKey:= ExpandConstant('SOFTWARE\{#MyAppShortPublisher}'); 
          RegDeleteKeyIfEmpty(HKLM, RegKey);

        end
      end;
    end;
  end
  else if (CurUninstallStep = usUninstall) then
  begin 
    while(CheckLaunchedApp) do
    begin
      if MsgBox(ExpandConstant('{cm:CloseApplicationWarning}'), mbConfirmation, MB_OKCANCEL) = IDCANCEL then
      begin
        ExitProcess(0);
      end;
    end;
  end;

end;
//===================================================
function InitializeUninstall(): Boolean;
//Return False to abort Uninstall, True otherwise.
begin
  Result:= true;
  exit;

end;
//===================================================
function UpdateReadyMemo(Space, NewLine, MemoUserInfoInfo, MemoDirInfo, MemoTypeInfo,
  MemoComponentsInfo, MemoGroupInfo, MemoTasksInfo: String): String;
var
  S: String;
  VersionString: String;
begin
//  { Fill the 'Ready Memo' with the normal settings and the custom settings }
  S := '';
  //S:= S + ExpandConstant('{cm:RMProgramFolder}') + NewLine;
  S:= S + MemoDirInfo + NewLine;
  S:= S + Space + QtFolderName + NewLine;
  S:= S + NewLine;
  
  S:= S + MemoGroupInfo + NewLine;
  S:= S + NewLine;
//  S := S + 'Personal Information:' + NewLine;
//  S := S + Space + UserPage.Values[0] + NewLine;
//  if UserPage.Values[1] <> '' then
//    S := S + Space + UserPage.Values[1] + NewLine;
//  S := S + NewLine;
  S:= S + MemoTasksInfo + NewLine;
  S:= S + NewLine;

  if(InstalledSettingsCount > 0) then
  begin
    if (InstalledSettingsImportPage.SelectedValueIndex > 0) then
    begin
      VersionString:= ExpandConstant('{cm:ReadyMemoApplyVersion1}');
      VersionString:= VersionString +' '+InstalledSettingsImportPage.CheckListBox.ItemCaption[InstalledSettingsImportPage.SelectedValueIndex]+' ';
      VersionString:= VersionString + ExpandConstant('{cm:ReadyMemoApplyVersion2}');  
    end
    else
    begin
     VersionString:= ExpandConstant('{cm:ReadyMemoDontApplyVersion}');  
    end;
   
    S:= S + VersionString;
    S:= S + NewLine;
  end;
 
  
//  S := S + 'Usage Mode:' + NewLine + Space;
//  case UsagePage.SelectedValueIndex of
//    0: S := S + 'Light mode';
//    1: S := S + 'Sponsored mode';
//    2: S := S + 'Paid mode';
//  end;
//  S := S + NewLine + NewLine;
  
//  S := S + MemoDirInfo + NewLine;
//  S := S + Space + DataDirPage.Values[0] + ' (personal data files)' + NewLine;

  Result := S;
end;

//  InstalledSettingsImportPage: TInputOptionWizardPage;
//  InstalledVersions: TArrayOfString;
//  InstalledVersionString: String;
//  InstalledSettingsCount: Integer;


//===================================================

// END CODE
